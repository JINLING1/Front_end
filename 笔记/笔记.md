# 📅 60 天前端学习计划

## 🎯 学习目标
在 60 天内夯实前端基础，掌握 HTML、CSS、JavaScript，并熟练使用 Vue3 进行项目开发，具备企业开发能力。

---

## 🗓️ 详细学习安排（每日任务）

### **第 1 阶段：夯实基础（1-20 天）**
#### **📌 HTML & CSS（1-10 天）**
- **Day 1**：HTML 基础（标签、属性、结构）
- **Day 2**：HTML 语义化、表单 & 表单验证
- **Day 3**：CSS 基础（选择器、优先级、文本样式）
- **Day 4**：CSS 盒模型、定位
- **Day 5**：Flexbox 布局、常见应用 4.1
- **Day 6**：Grid 布局、CSS 响应式设计
- **Day 7**：CSS 动画（transition、animation）
- **Day 8**：手写一个静态页面练习
- **Day 9**：复习 HTML & CSS 重点知识，做小测验
- **Day 10**：综合练习：使用 HTML + CSS 完成一个小型页面

#### **📌 JavaScript 基础（11-20 天）**
- **Day 11**：JavaScript 变量、数据类型、作用域
- **Day 12**：条件语句、循环、函数（声明 & 表达式）
- **Day 13**：数组 & 对象操作（增删改查）
- **Day 14**：ES6 语法（解构、展开、箭头函数）
- **Day 15**：DOM 操作（获取元素、修改样式、事件监听）
- **Day 16**：事件委托 & 事件冒泡机制
- **Day 17**：手写一个 Todo List 小项目
- **Day 18**：JS 异步编程基础（setTimeout、Promise）
- **Day 19**：复习 JavaScript 重点知识，做小测验
- **Day 20**：综合练习：完成一个带交互功能的前端小项目

---

### **第 2 阶段：JavaScript 深入 & Vue3 入门（21-40 天）**
#### **📌 JavaScript 进阶（21-30 天）**
- **Day 21**：闭包、原型链、this 绑定
- **Day 22**：作用域链 & 执行上下文
- **Day 23**：Promise、async/await 解析
- **Day 24**：事件循环机制 & 微任务、宏任务
- **Day 25**：模块化（ESModule, CommonJS）
- **Day 26**：手写一个 AJAX 请求，模拟 Fetch API
- **Day 27**：手写防抖、节流函数
- **Day 28**：复习 JavaScript 进阶知识
- **Day 29**：完成一个 JS 复杂应用练习
- **Day 30**：JavaScript 知识测验 & 小项目实战

#### **📌 Vue3 基础（31-40 天）**
- **Day 31**：Vue3 组件化开发（Composition API、Options API）
- **Day 32**：Vue3 响应式系统（ref、reactive）
- **Day 33**：Vue3 事件、生命周期、插槽
- **Day 34**：Vue Router 基础（路由跳转、动态路由）
- **Day 35**：Vuex（Pinia）状态管理入门
- **Day 36**：Vue3 组件封装技巧
- **Day 37**：手写一个 Vue3 组件库（基础组件）
- **Day 38**：Vue3 练习：小项目开发
- **Day 39**：复习 Vue3 重点知识，做小测验
- **Day 40**：Vue3 小项目总结 & 调优

---

### **第 3 阶段：企业开发实战 & 项目提升（41-60 天）**
#### **📌 进阶 Vue3 & TypeScript（41-50 天）**
- **Day 41**：Vue3 + TypeScript 结合开发
- **Day 42**：Vue3 组合式 API 深入
- **Day 43**：Vue3 自定义 Hook 开发
- **Day 44**：Vue3 状态管理方案（Vuex / Pinia）
- **Day 45**：Vue3 组件库封装技巧
- **Day 46**：Vue3 项目架构设计 & 代码优化
- **Day 47**：手写 Vue3 动态表单组件
- **Day 48**：Vue3 练习：中型项目开发
- **Day 49**：Vue3 重点回顾 & 小测验
- **Day 50**：复盘 Vue3 代码实践 & 小项目优化

#### **📌 前端工程化 & 企业开发（51-60 天）**
- **Day 51**：Webpack & Vite 配置优化
- **Day 52**：组件库搭建（按需加载、自动引入）
- **Day 53**：Git 版本管理 & 团队协作
- **Day 54**：前端性能优化（首屏优化、懒加载）
- **Day 55**：前端安全（XSS、CSRF）
- **Day 56**：部署前端项目到 Vercel/Netlify
- **Day 57**：项目开发（完整业务流程）
- **Day 58**：项目调试 & Bug 修复
- **Day 59**：项目总结 & 代码优化
- **Day 60**：最终挑战：独立完成企业级 Vue3 项目

---

## 🛠️ 适用学习资源
- **HTML & CSS**: [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web)
- **JavaScript**: [JavaScript 高级程序设计](https://book.douban.com/subject/10546125/)
- **Vue3**: [Vue 官方文档](https://cn.vuejs.org/)
- **实战项目**: [Vue3 开源项目示例](https://github.com/vuejs/awesome-vue)

---

## ✅ 进度评估方式
- 每日 Typora 记录学习笔记（Markdown 格式）
- 每 10 天进行一次知识复盘 & 小测验
- 每周完成至少 1 个小项目
- 60 天后能够独立开发 Vue3 企业项目

---

# 另外补充零碎知识点

**CSS自定义属性**` --custom_properties`


# Day1

## HTML 基础（标签、属性、结构）

[HTML 教程 | 菜鸟教程](https://www.runoob.com/html/html-tutorial.html)

### HTML基本结构

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 页面内容 -->
</body>
</html>

```



### HTML属性

属性是 HTML 元素提供的附加信息。

属性通常出现在 HTML 标签的开始标签中，用于定义元素的行为、样式、内容或其他特性。

属性总是以 **name="value"** 的形式写在标签内，**name** 是属性的名称，**value** 是属性的值。

<a>标签的`target`属性用于指定链接的打开方式，默认为`self`即当前窗口

### HTML标签

#### 嵌套规则

行内元素可以嵌套在块级元素内，但块级元素不能嵌套在行内元素内。

- **行内元素（Inline elements）**：这些元素不会占据整行，而是与其他元素在同一行显示。常见的行内元素有：
  - `<span>`、`<a>`、`<strong>`、`<em>` 等。
- **块级元素（Block-level elements）**：这些元素会占据整行，并且通常用于结构化布局。常见的块级元素有：
  - `<div>`、`<p>`、`<h1>`、`<ul>`、`<li>` 等。

- **`<div>`** 是块级标签（Block-level element），它会占据整行，通常用于布局和容器。例如，你可以用它来包裹一段内容或其他元素。块级元素通常会在页面上从新的一行开始显示。

  例子：

  ```html
  <div>
      <h1>标题</h1>
      <p>这是一段内容。</p>
  </div>
  ```

- **`<span>`** 是行内标签（Inline element），它不会单独占用一行，而是与其他元素在同一行显示。通常用于对文本进行样式修改或者包裹小范围的内容。

  例子：

  ```html
  <p>这是一个 <span style="color: red;">红色</span> 字段。</p>
  ```

总结：

- `<div>`：块级元素，占满一整行，可以包含块级和行内元素。
- `<span>`：行内元素，只占用它的内容的宽度，不会换行。



#### 常见的HTML表单标签和控件：

1. **`<input>`**：用于创建各种类型的输入控件。根据 `type` 属性的不同，`<input>` 可以变成不同的表单控件，例如文本框、复选框、单选按钮等。

   ```html
   <input type="text" name="username"> <!-- 文本输入框 -->
   <input type="password" name="password"> <!-- 密码输入框 -->
   <input type="radio" name="gender" value="male"> <!-- 单选按钮 -->
   <input type="checkbox" name="subscribe" value="yes"> <!-- 复选框 -->
   <input type="submit" value="提交"> <!-- 提交按钮 -->
   ```

2. **`<label>`**：为表单控件提供标签，用于描述该控件的功能。通过 `for` 属性，可以将 `<label>` 与特定的表单控件绑定。

   ```html
   <label for="username">用户名：</label>
   <input type="text" id="username" name="username">
   ```

   这样，当用户点击 "用户名：" 标签时，光标会自动跳到对应的输入框。

3. **`<select>`**：创建下拉列表，允许用户选择一个或多个选项。

   ```html
   <select name="country">
     <option value="china">中国</option>
     <option value="usa">美国</option>
     <option value="japan">日本</option>
   </select>
   ```

4. **`<textarea>`**：用于创建多行文本输入框，常用于让用户输入较长的文本。

   ```html
   <textarea name="message" rows="4" cols="50">请输入您的留言</textarea>
   ```

5. **`<button>`**：创建按钮，常用于提交表单或执行其他操作。

   ```html
   <button type="submit">提交</button>
   ```

6. **`<form>`**：定义一个表单，包含了所有的输入控件和提交按钮。

   ```html
   <form action="/submit_form" method="post">
     <label for="username">用户名：</label>
     <input type="text" id="username" name="username">
     <input type="submit" value="提交">
   </form>
   ```



# Day2

## HTML 语义化、表单 & 表单验证

### HTML表单

[表单数据校验 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Extensions/Forms/Form_validation)

#### HTML5 内置表单验证

HTML5 提供了一些内置验证功能，例如：

- **`required`**：必填字段。
- **`minlength` 和 `maxlength`**：字符最小/最大长度。
- **`pattern`**：使用正则表达式匹配输入内容。
- **`type`**：例如 `email`（自动验证邮箱格式）、`number`（只能输入数字）、`url`（只能输入网址）。
- **`min` 和 `max`**：用于数字输入的最小/最大值。

**示例：**

```
html复制编辑<input type="text" name="username" required minlength="4" maxlength="16">
<input type="email" name="email" required>
<input type="password" name="password" required pattern=".{6,}" title="密码至少 6 个字符">
```

------

#### JavaScript 自定义验证

HTML5 内置验证只能处理基础需求，复杂验证（如密码强度、两次密码匹配等）需要 JavaScript。

##### **（1）实时验证输入**

```html
<input type="text" id="username" required>
<p id="username-error" style="color: red; display: none;">用户名至少 4 个字符</p>

<script>
    document.getElementById("username").addEventListener("input", function () {
        let username = this.value;
        let errorMsg = document.getElementById("username-error");
        
        if (username.length < 4) {
            errorMsg.style.display = "block";
        } else {
            errorMsg.style.display = "none";
        }
    });
</script>
```

##### （2）提交前检查表单

```html
<form id="registerForm">
    <input type="password" id="password" placeholder="密码" required>
    <input type="password" id="confirmPassword" placeholder="确认密码" required>
    <p id="error-message" style="color: red; display: none;">两次密码不一致！</p>
    <button type="submit">提交</button>
</form>

<script>
    document.getElementById("registerForm").addEventListener("submit", function (event) {
        let password = document.getElementById("password").value;
        let confirmPassword = document.getElementById("confirmPassword").value;
        let errorMsg = document.getElementById("error-message");

        if (password !== confirmPassword) {
            errorMsg.style.display = "block";
            event.preventDefault(); // 阻止表单提交
        } else {
            errorMsg.style.display = "none";
        }
    });
</script>
```

### HTML语义化

#### 1. 什么是HTML 语义化？
HTML 语义化指的是使用具有 **明确含义** 的标签，而不是单纯的 `<div>` 或 `<span>`，使得代码更具可读性、可访问性和 SEO 友好性。

例如，使用 `<header>` 而不是 `<div class="header">`，让浏览器和开发者都能清楚这个部分是 **网页的头部**。

------

#### **2. 常见的语义化标签**

| 语义化标签     | 作用                                       |
| -------------- | ------------------------------------------ |
| `<header>`     | 定义网页的头部，通常包含 logo、导航等      |
| `<nav>`        | 表示导航栏，包含网站主要链接               |
| `<main>`       | 页面主要内容，每个页面仅有一个 `<main>`    |
| `<section>`    | 表示一个独立的内容区域，通常有标题         |
| `<article>`    | 表示一篇独立的文章，如博客、新闻           |
| `<aside>`      | 侧边栏，通常放额外信息（广告、推荐文章等） |
| `<footer>`     | 页脚，通常包含版权信息、联系方式等         |
| `<figure>`     | 用于包裹图像、图表、代码块等               |
| `<figcaption>` | `figure` 内的标题或描述                    |
| `<mark>`       | 让文本高亮显示，表示重要信息               |
| `<time>`       | 定义时间，可以被搜索引擎识别               |

------

#### **3. 语义化 HTML 代码示例**

```html
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML 语义化示例</title>
</head>
<body>

    <header>
        <h1>我的网站</h1>
        <nav>
            <ul>
                <li><a href="#">首页</a></li>
                <li><a href="#">关于</a></li>
                <li><a href="#">联系</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section>
            <h2>最新文章</h2>
            <article>
                <h3>HTML 语义化的好处</h3>
                <p>使用语义化 HTML 有助于 SEO，并提高代码可读性。</p>
                <figure>
                    <img src="html.jpg" alt="HTML 结构示意图">
                    <figcaption>HTML 语义化示例</figcaption>
                </figure>
            </article>
        </section>
    </main>

    <aside>
        <h2>推荐阅读</h2>
        <ul>
            <li><a href="#">CSS 语义化</a></li>
            <li><a href="#">JavaScript 最佳实践</a></li>
        </ul>
    </aside>

    <footer>
        <p>&copy; 2025 我的博客. All rights reserved.</p>
    </footer>

</body>
</html>
```

------

#### 4. 为什么要使用语义化 HTML？

 ✅ 可读性更强：开发者可以更直观地理解代码结构。
 ✅ 有助于 SEO：搜索引擎可以更准确地索引网页内容，提高排名。
 ✅ 可访问性增强：屏幕阅读器可以更好地解析内容，方便残障用户浏览。
 ✅ 更容易维护：代码结构清晰，便于修改和扩展。

# Day3	

## **CSS 基础（选择器、优先级、文本样式）**

CSS（Cascading Style Sheets，层叠样式表）用于控制网页的外观。你可以使用 CSS 设置 **颜色、字体、布局** 等样式。今天我们重点学习 **选择器、优先级、文本样式**。

------

### **1️⃣ CSS 选择器**

选择器用于 **选中 HTML 元素** 并应用样式。常见选择器有以下几种：

#### **🔹 基础选择器**

| 选择器           | 作用           | 示例                                    |
| ---------------- | -------------- | --------------------------------------- |
| **元素选择器**   | 选择 HTML 标签 | `p { color: red; }` （所有 `<p>` 变红） |
| **类选择器**     | 选择 class     | `.btn { background: blue; }`            |
| **ID 选择器**    | 选择 id        | `#header { font-size: 20px; }`          |
| **通配符选择器** | 选择所有元素   | `* { margin: 0; }`                      |

**示例：**

```css
p {
  color: blue;
}
.btn {
  background-color: yellow;
}
#header {
  font-size: 24px;
}
```

------

#### **🔹 组合选择器**

| 选择器                      | 作用                | 示例                        |
| --------------------------- | ------------------- | --------------------------- |
| **后代选择器（A B）**       | 选择 A 内的所有 B   | `div p { color: red; }`     |
| **子代选择器（A > B）**     | 选择 A 直接子元素 B | `div > p { color: blue; }`  |
| **相邻兄弟选择器（A + B）** | 选择紧邻 A 之后的 B | `h1 + p { color: green; }`  |
| **通用兄弟选择器（A ~ B）** | 选择 A 之后的所有 B | `h1 ~ p { color: purple; }` |
| **选中多个**                | 选择A，B...         | `h1 + h2 {color:blue;}`     |

**示例：**

```css
/* 选择 div 内的所有 p */
div p {
  color: red;
}

/* 只选择 div 的直接子 p */
div > p {
  font-size: 18px;
}

/* 选择 h1 后紧挨着的 p */
h1 + p {
  font-weight: bold;
}
```

------

#### **🔹 属性选择器**

| 选择器            | 作用                          | 示例                                            |
| ----------------- | ----------------------------- | ----------------------------------------------- |
| `[attr]`          | 选择有某属性的元素            | `[disabled] { color: gray; }`                   |
| `[attr="value"]`  | 选择属性值等于 value 的元素   | `input[type="text"] { border: 1px solid red; }` |
| `[attr^="value"]` | 选择属性值以 value 开头的元素 | `a[href^="https"] { color: blue; }`             |
| `[attr$="value"]` | 选择属性值以 value 结尾的元素 | `a[href$=".pdf"] { color: green; }`             |
| `[attr*="value"]` | 选择属性值包含 value 的元素   | `p[class*="important"] { font-weight: bold; }`  |

**示例：**

```css
/* 选择所有禁用的输入框 */
input[disabled] {
  background: lightgray;
}

/* 选择所有文本输入框 */
input[type="text"] {
  border: 1px solid black;
}
```

------

### **2️⃣ CSS 优先级（权重计算）**

当多个规则作用于同一个元素时，浏览器按照 **优先级** 选择应用哪个规则。

#### **🔹 规则**

**权重计算规则：**

1. **内联样式（`style=""`）** `1000`
2. **ID 选择器（`#id`）** `100`
3. **类、伪类、属性选择器（`.class`、`:hover`、`[attr]`）** `10`
4. **元素选择器（`div`、`h1`、`p`）** `1`
5. **通配符 `\*`、继承样式** `0`

**示例：**

```css
h1 { color: blue; }        /* 权重 1 */
#title { color: red; }     /* 权重 100 */
.title { color: green; }   /* 权重 10 */
```

如果 `h1` 既有 `#title` 也有 `.title`，最终应用 **红色（ID 选择器）**。

💡 **小技巧：**

- **尽量避免使用 ID 选择器**，用 **类选择器** 代替。
- **不要滥用 `!important`**，否则很难修改样式。

------

### **3️⃣ 文本样式**

#### **🔹 字体**

| CSS 属性         | 作用       | 示例                              |
| ---------------- | ---------- | --------------------------------- |
| `font-size`      | 字体大小   | `font-size: 16px;`                |
| `font-family`    | 字体       | `font-family: Arial, sans-serif;` |
| `font-weight`    | 字体粗细   | `font-weight: bold;`              |
| `font-style`     | 斜体       | `font-style: italic;`             |
| `text-transform` | 文字大小写 | `text-transform: uppercase;`      |

**示例：**

```css
p {
  font-size: 18px;
  font-family: "Arial", sans-serif;
  font-weight: bold;
}
```

------

#### **🔹 文本对齐**

| CSS 属性      | 作用     | 示例                  |
| ------------- | -------- | --------------------- |
| `text-align`  | 文本对齐 | `text-align: center;` |
| `text-indent` | 首行缩进 | `text-indent: 20px;`  |
| `line-height` | 行高     | `line-height: 1.5;`   |

**示例：**

```css
p {
  text-align: justify;
  text-indent: 20px;
  line-height: 1.6;
}
```

------

#### **🔹 文本修饰**

| CSS 属性          | 作用             | 示例                          |
| ----------------- | ---------------- | ----------------------------- |
| `text-decoration` | 下划线、删除线等 | `text-decoration: underline;` |
| `letter-spacing`  | 字母间距         | `letter-spacing: 2px;`        |
| `word-spacing`    | 单词间距         | `word-spacing: 5px;`          |

**示例：**

```css
a {
  text-decoration: none;
}
```

------

#### **🔹 颜色**

| CSS 属性           | 作用     | 示例                        |
| ------------------ | -------- | --------------------------- |
| `color`            | 文字颜色 | `color: red;`               |
| `background-color` | 背景颜色 | `background-color: yellow;` |

**示例：**

```css
h1 {
  color: #ff5733;
  background-color: black;
}
```

------

# Day4


## **1️⃣ 盒模型（Box Model）**

每个 HTML 元素在浏览器中都被当作一个 **矩形盒子**，其结构如下：

![image-20250330211552090](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20250330211552090.png)

盒模型由 **四个部分** 组成（从内到外）：

1. **内容（content）**：元素的实际内容区域，如文本、图片等。
2. **内边距（padding）**：围绕内容的空间，增加填充效果。
3. **边框（border）**：包裹内容和内边距的边界。
4. **外边距（margin）**：元素与其他元素之间的距离。

### **🔹 盒模型相关属性**

| CSS 属性           | 作用             | 示例                           |
| ------------------ | ---------------- | ------------------------------ |
| `width` / `height` | 盒子的宽度和高度 | `width: 200px; height: 100px;` |
| `padding`          | 内边距           | `padding: 10px;`               |
| `border`           | 边框             | `border: 2px solid black;`     |
| `margin`           | 外边距           | `margin: 20px;`                |
| `box-sizing`       | 盒模型计算方式   | `box-sizing: border-box;`      |

**示例：**

```css
.box {
  width: 200px;
  height: 100px;
  padding: 10px;
  border: 2px solid blue;
  margin: 20px;
  box-sizing: border-box; /* 让宽高包含 padding 和 border */
}
```

📌 **`box-sizing: border-box;`** 能确保 `width` 和 `height` 包含 `padding` 和 `border`，避免盒子尺寸超出预期。

### **📌 `box-sizing: border-box;` 详解**

`box-sizing` 是 CSS 的一个属性，控制元素的宽高计算方式。默认情况下，**元素的 `width` 和 `height` 只包含内容 (`content`)，但不包含 `padding` 和 `border`**，这有时会导致盒子尺寸超出预期。因此，我们可以使用 `box-sizing: border-box;` 来改变计算方式。

------

#### **1️⃣ `box-sizing` 的两种模式**

| 值                    | 说明                                                         | 计算方式                              |
| --------------------- | ------------------------------------------------------------ | ------------------------------------- |
| `content-box`（默认） | `width` 和 `height` 只计算 `content`，不包括 `padding` 和 `border` | `总宽度 = content + padding + border` |
| `border-box`          | `width` 和 `height` **包含** `content`、`padding` 和 `border` | `总宽度 = width（包含所有）`          |

------

#### **2️⃣ `content-box`（默认模式）**

在 `content-box` 模式下：

- `width` 和 `height` **只包含内容**，**不包含 `padding` 和 `border`**。
- 盒子的**实际大小** = `width` + `padding` + `border`。

##### **🌟 示例**

```css
.box {
  width: 200px;
  height: 100px;
  padding: 20px;
  border: 10px solid black;
  box-sizing: content-box;
}
```

📌 **计算实际大小**

- `内容宽度`: 200px
- `左右 padding`: 20px × 2 = **40px**
- `左右 border`: 10px × 2 = **20px**
- **最终盒子宽度**: **200 + 40 + 20 = 260px**
- `内容高度`: 100px
- `上下 padding`: 20px × 2 = **40px**
- `上下 border`: 10px × 2 = **20px**
- **最终盒子高度**: **100 + 40 + 20 = 160px**

❌ **问题：`width` 设定 200px，但最终盒子实际变大到 260px！**

------

#### **3️⃣ `border-box`（推荐模式）**

在 `border-box` 模式下：

- **`width` 和 `height` 包括 `content`、`padding` 和 `border`**。
- 盒子的**实际大小固定为 `width`**，不会因为 `padding` 和 `border` 变大。

##### **🌟 示例**

```css
.box {
  width: 200px;
  height: 100px;
  padding: 20px;
  border: 10px solid black;
  box-sizing: border-box;
}
```

📌 **计算实际大小**

- `盒子总宽度`: 200px（固定，不会变大）
- `内容宽度`: **200 - (20px × 2) - (10px × 2) = 140px**
- `盒子总高度`: 100px（固定）

✅ **优点**

- `width` 仍然是 200px，不会因 `padding` 和 `border` 变大。
- 适用于 **响应式布局**，不会让盒子尺寸超出预期。

------

#### **4️⃣ `border-box` 的最佳实践**

💡 在现代开发中，通常会 **全局启用 `border-box`**，避免盒子因 `padding` 和 `border` 撑大：

```css
* {
  box-sizing: border-box;
}
```

这样所有元素的 `width` 都是 **包含 `padding` 和 `border` 的总大小**，布局更可控。

------

#### **5️⃣ `border-box` VS `content-box` 对比**

| 模式          | `width: 200px; padding: 20px; border: 10px solid;`       | 实际宽度  |
| ------------- | -------------------------------------------------------- | --------- |
| `content-box` | 只算 `content`，最终 **200 + 40 + 20 = 260px**           | **260px** |
| `border-box`  | `width` 包含 `padding` 和 `border`，最终宽度 **= 200px** | **200px** |



------

#### **💡 总结**

🔹 `box-sizing` 影响元素的尺寸计算方式：

1. **默认 `content-box`**：`width` 只包含内容，`padding` 和 `border` 额外加上去，可能导致尺寸超出预期。
2. **推荐 `border-box`**：`width` 包含 `padding` 和 `border`，**保证盒子尺寸不会超出设定值**，布局更可控。

------

## **2️⃣ 定位（Positioning）**

CSS 提供了 **五种定位方式**，用于控制元素的摆放方式。

#### **🔹 `position` 属性**

| 值         | 作用     | 说明                                        |
| ---------- | -------- | ------------------------------------------- |
| `static`   | 默认定位 | 按照文档流排列（不受 `top`、`left` 等影响） |
| `relative` | 相对定位 | 相对于自身原始位置移动                      |
| `absolute` | 绝对定位 | 脱离文档流，相对于最近的**定位祖先**        |
| `fixed`    | 固定定位 | 脱离文档流，相对于**视口（viewport）**固定  |
| `sticky`   | 粘性定位 | 滚动时变为 `fixed`，但受 `top` 等属性约束   |

------

### **🔹 `static`（默认定位）**

**`position: static;`** 是所有元素的默认定位，按 **文档流** 排列，不受 `top` / `left` 等影响。

```css
.box {
  position: static;
  top: 50px;  /* ❌ 无效 */
  left: 100px;  /* ❌ 无效 */
}
```

------

### **🔹 `relative`（相对定位）**

- **相对于自身原位置** 移动，不影响其他元素的位置。
- **不会脱离文档流**。

```css
.box {
  position: relative;
  top: 20px;   /* 向下移动 20px */
  left: 30px;  /* 向右移动 30px */
}
```

✅ **适用场景**：微调元素的位置，同时保留原来的占位。

------

### **🔹 `absolute`（绝对定位）**

- **脱离文档流**，不会影响其他元素。
- **相对于最近的** `position: relative/absolute/fixed` **祖先元素**（如果没有，则相对于 `body`）。

```css
.container {
  position: relative; /* 作为参考父元素 */
}
.box {
  position: absolute;
  top: 20px;   /* 相对于 .container 顶部 20px */
  left: 30px;  /* 相对于 .container 左侧 30px */
}
```

✅ **适用场景**：浮动按钮、弹出层、模态框等。

------

### **🔹 `fixed`（固定定位）**

- **脱离文档流**，不会影响其他元素。
- **始终固定在视口（viewport）的位置**，滚动页面时不会移动。

```css
.fixed-box {
  position: fixed;
  bottom: 10px;   /* 贴近底部 */
  right: 10px;   /* 贴近右侧 */
}
```

✅ **适用场景**：返回顶部按钮、导航栏固定在页面顶部。

------

### **🔹 `sticky`（粘性定位）**

- **既是相对定位又是固定定位的结合体**。
- 当滚动到一定位置时，元素会变成 **固定状态**。

```css
.sticky-box {
  position: sticky;
  top: 20px;  /* 当滚动超过 20px 后固定 */
}
```

✅ **适用场景**：固定导航栏、表头固定在顶部。

## **💡 总结**

1. **盒模型（Box Model）** 由 `content`、`padding`、`border` 和 `margin` 组成。
2. **`box-sizing: border-box;`** 让 `width` 和 `height` 包括 `padding` 和 `border`。
3. **定位（Position）**
   - `static`：默认，不受 `top/left` 影响。
   - `relative`：相对原位置移动，不脱离文档流。
   - `absolute`：脱离文档流，相对于最近的定位父元素。
   - `fixed`：固定在视口，不随滚动条滚动。
   - `sticky`：滚动到某处后固定，但不完全脱离文档流。

# Day5

## **📌 Flexbox 布局（弹性布局）详解**

Flexbox（弹性盒模型）是一种用于 **一维布局（单行或单列）** 的 CSS 布局方式，适用于 **水平或垂直方向上的内容对齐** 和 **空间分配**。

------

## **1️⃣ Flexbox 基本概念**

### **📌 主要组成部分**

- **容器（Flex Container）**：使用 `display: flex;` 或 `display: inline-flex;` 定义。
- **项目（Flex Items）**：容器中的直接子元素，受 Flexbox 规则影响。

```css
.container {
  display: flex;
}
```

### **📌 轴的概念**

1. **主轴（Main Axis）**：决定 **项目的排列方向**，默认是 **横向（从左到右）**。
2. **交叉轴（Cross Axis）**：垂直于主轴的方向。

| 方向       | `flex-direction: row;` (默认) | `flex-direction: column;` |
| ---------- | ----------------------------- | ------------------------- |
| **主轴**   | 水平方向（→）                 | 竖直方向（↓）             |
| **交叉轴** | 垂直方向（↓）                 | 水平方向（→）             |

------

## **2️⃣ 容器属性（控制子项排列）**

### **🔹 `display: flex;`**

- 让容器变成弹性布局，子项自动变为弹性盒子。

```css
.container {
  display: flex;
}
```

------

### **🔹 `flex-direction`（主轴方向）**

- 控制 **子项的排列方向**（水平/垂直）。

| 值               | 作用                                   |
| ---------------- | -------------------------------------- |
| `row`            | **默认值**，从左到右排列（主轴：水平） |
| `row-reverse`    | 从右到左排列                           |
| `column`         | 从上到下排列（主轴：垂直）             |
| `column-reverse` | 从下到上排列                           |

```css
.container {
  display: flex;
  flex-direction: row; /* 默认：横向排列 */
}
```

------

### **🔹 `justify-content`（主轴对齐方式）**

- 控制 **子项在主轴上的对齐方式**。

| 值              | 效果                                                   |
| --------------- | ------------------------------------------------------ |
| `flex-start`    | **默认**，左对齐（主轴起点）                           |
| `flex-end`      | 右对齐（主轴终点）                                     |
| `center`        | 居中对齐                                               |
| `space-between` | **两端对齐**（首尾贴边，项目均匀分布）                 |
| `space-around`  | **环绕分布**（项目之间间距相等，每个项目两侧都有间距） |
| `space-evenly`  | **均匀分布**（所有间距相等）                           |

```css
.container {
  display: flex;
  justify-content: center; /* 项目水平居中 */
}
```

------

### **🔹 `align-items`（交叉轴对齐方式）**

- 控制 **子项在交叉轴上的对齐方式**。

| 值           | 效果                                              |
| ------------ | ------------------------------------------------- |
| `stretch`    | **默认值**，子项高度填充容器（需未设定 `height`） |
| `flex-start` | 顶部对齐（交叉轴起点）                            |
| `flex-end`   | 底部对齐（交叉轴终点）                            |
| `center`     | 居中对齐                                          |
| `baseline`   | **基线对齐**（根据文本基线对齐）                  |

```css
.container {
  display: flex;
  align-items: center; /* 子项在交叉轴上居中 */
}
```

------

### **🔹 `align-content`（多行对齐方式）**

- 作用于 **多行弹性布局**（`flex-wrap: wrap;`）。
- 控制 **整行在交叉轴上的排列方式**。

| 值              | 效果                 |
| --------------- | -------------------- |
| `flex-start`    | **默认值**，顶部对齐 |
| `flex-end`      | 底部对齐             |
| `center`        | 居中对齐             |
| `space-between` | 两端对齐             |
| `space-around`  | 每行之间的间距相等   |
| `stretch`       | 拉伸填充整个容器     |

```css
.container {
  display: flex;
  flex-wrap: wrap;
  align-content: center; /* 多行居中对齐 */
}
```
### **🔹`flex-wrap`(定义子元素是否换行)**
|值 				|效果				|
|----------------|----------------|
|`no-wrap`	|不换行（默认）|
|`wrap`|换行|
|`wrap-reverse`|换行后按相反顺序排序（蛇形）|

------

## **3️⃣ 子项属性（控制单个元素）**

### **🔹 `flex-grow`（伸展比例）**

- 控制 **项目的增长比例**，默认 `0`（不增长）。
- **值越大，项目占据的空间越多**。

```css
.item {
  flex-grow: 1; /* 所有子项均分空间 */
}
```

------

### **🔹 `flex-shrink`（收缩比例）**

- 控制 **项目的缩小比例**，默认 `1`即所有元素在需要收缩时收缩的比例相同。
- **值越大，项目收缩得越多**。

```css
.item {
  flex-shrink: 2; /* 该项比默认项缩小得更快 */
}
```

------

### **🔹 `flex-basis`（初始大小）**

- 控制 **主轴上的初始尺寸**，类似于 `width` / `height`。
- `auto`（默认）时，取 `width` 或 `height` 作为初始大小。

```css
.item {
  flex-basis: 100px; /* 项目初始宽度 100px */
}
```

------

### **🔹 `flex`（简写）**

**等价于：`flex-grow flex-shrink flex-basis`**

```css
.item {
  flex: 1 1 auto; /* 默认值 */
}
```

- `flex: 1;` **等价于** `flex-grow: 1; flex-shrink: 1; flex-basis: 0%;`

------

### **🔹 `align-self`（单个子项对齐方式）**

- **覆盖 `align-items` 规则**，用于单独调整某个子项。

| 值           | 效果                  |
| ------------ | --------------------- |
| `auto`       | 继承 `align-items` 值 |
| `flex-start` | 顶部对齐              |
| `flex-end`   | 底部对齐              |
| `center`     | 居中对齐              |
| `baseline`   | 基线对齐              |
| `stretch`    | 填充交叉轴            |

```css
.item {
  align-self: flex-end; /* 该项底部对齐 */
}
```

------

## **4️⃣ Flexbox 常见应用**

### **📌 1. 水平垂直居中**

```css
.container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
```

### **📌 2. 两栏布局**

```css
.container {
  display: flex;
}
.sidebar {
  flex: 1; /* 占 1 份 */
}
.content {
  flex: 3; /* 占 3 份 */
}
```

### **📌 3. 等宽布局**

```css
.container {
  display: flex;
}
.item {
  flex: 1;
}
```

### **📌 4. 响应式导航栏**

```css
.nav {
  display: flex;
  justify-content: space-between;
}
```

------

## **💡 总结**

✅ **Flexbox 适用于**：

- 一维布局（单行/单列）。
- 适用于 **居中对齐、等宽布局、导航栏、响应式设计** 等。

✅ **核心概念**：

- `display: flex;`
- `flex-direction` 决定 **主轴方向**。
- `justify-content` 控制 **主轴对齐方式**。
- `align-items` 控制 **交叉轴对齐方式**。
- `flex` 组合了 `grow`, `shrink`, `basis`。

🔹 **Flexbox + `gap`（CSS Grid 也支持）**：

设置元素之间间隙

```css
.container {
  display: flex;
  gap: 10px;
}
```

✨ **让布局更简洁高效！** 🚀

# Day6

## Grid 布局

CSS Grid 是一种用于创建复杂布局的强大工具，它允许开发者将网页内容分布到一个网格系统中。通过设定行和列，开发者可以精确控制网页元素的位置。

### 基本概念

- **Grid Container**：定义了网格容器，通过 `display: grid;` 或 `display: inline-grid;` 来声明。
- **Grid Items**：网格容器中的元素，它们被自动分配到网格中。

```css
.container {
  display: grid;
}
```

### 定义行和列

使用 `grid-template-rows` 和 `grid-template-columns` 来定义网格的行和列。例如：

```css
.container {
  display: grid;
  grid-template-columns: 100px 200px; /* 2列，第一列宽100px，第二列宽200px */
  grid-template-rows: 50px 100px; /* 2行，第一行高50px，第二行高100px */
}
```

这会将 `.container` 设置为一个 2x2 的网格，其中列宽分别为 `100px` 和 `200px`，行高分别为 `50px` 和 `100px`。

### `grid-gap` 或 `gap`

`grid-gap`**已弃用**（推荐简写为 `gap`）用于设置行和列之间的间距。可以同时设置行间距和列间距，也可以单独设置。

```css
.container {
  display: grid;
  grid-template-columns: 100px 200px;
  grid-template-rows: 50px 100px;
  gap: 10px; /* 行和列之间的间距为 10px */
}
```

你可以分别设置行和列间距：

```css
.container {
  display: grid;
  grid-template-columns: 100px 200px;
  grid-template-rows: 50px 100px;
  row-gap: 20px; /* 行间距 */
  column-gap: 30px; /* 列间距 */
}
```

### `grid-column` 和 `grid-row`

- **`grid-column`**：设置网格项在 **水平** （列）方向的位置。
- **`grid-row`**：设置网格项在 **垂直** （行）方向的位置。

这两个属性的值通常有两种形式：

1. **起始位置 / 结束位置**：指定网格项的起始和结束位置。
2. **`span`**：指定网格项跨越多少列或行。

例如：

```css
.item {
  grid-column: 1 / span 2; /* 占两列 */
  grid-row: 1 / span 2;    /* 占两行 */
}
```

**`grid-column: 1 / span 2;`**

- `1`：起始列为第 1 列。
- `span 2`：占据 2 列，从第 1 列开始，跨越 2 列。

**`grid-row: 1 / span 2;`**

- `1`：起始行为第 1 行。
- `span 2`：占据 2 行，从第 1 行开始，跨越 2 行。

### 网格布局的定位

- **`grid-column-start`**：设置网格项在水平方向上起始位置的线。
- **`grid-column-end`**：设置网格项在水平方向上结束位置的线。
- **`grid-row-start`**：设置网格项在垂直方向上起始位置的线。
- **`grid-row-end`**：设置网格项在垂直方向上结束位置的线。

这四个属性的值可以是数字（指定网格线），也可以是 `span`（表示跨越的列数或行数）。

### 实际应用举例

```css
.container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr; /* 三等分列 */
  grid-template-rows: auto; /* 行高自动调整 */
  gap: 10px; /* 网格间距 */
}

.item1 {
  grid-column: 1 / span 2; /* 占据前两列 */
  grid-row: 1; /* 在第一行 */
}

.item2 {
  grid-column: 3; /* 在第三列 */
  grid-row: 1; /* 在第一行 */
}
```

### 自动布局与网格模板

- **`grid-template-areas`**：指定网格区域的名称，可以通过这些区域名将网格项分配到指定的区域。

```css
.container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-template-areas:
    "header header header"
    "main main sidebar"
    "footer footer footer";
}
```

在上面的例子中，网格项将根据 `grid-template-areas` 中定义的区域来排列，例如：

```css
.header { grid-area: header; }
.main { grid-area: main; }
.sidebar { grid-area: sidebar; }
.footer { grid-area: footer; }
```

## CSS 响应式设计

响应式设计是为了让网页在各种设备上都有良好的展示效果。主要通过媒体查询（`@media`）来实现。

### 基本概念

- **`@media`**：用来根据设备的特性（如屏幕宽度、分辨率等）应用不同的样式。

```css
@media (max-width: 600px) {
  .container {
    grid-template-columns: 1fr; /* 屏幕宽度小于600px时，使用单列布局 */
  }
}
```

### 响应式设计中的常见用法

1. **调整布局：**

```css
@media (max-width: 768px) {
  .container {
    grid-template-columns: 1fr; /* 小屏幕下单列布局 */
  }
}
```

1. **调整字体大小：**

```css
@media (max-width: 600px) {
  body {
    font-size: 14px; /* 在小屏幕下，字体变小 */
  }
}
```

### 使用 `min-width` 和 `max-width`

- **`min-width`**：当设备宽度大于或等于指定值时应用样式。
- **`max-width`**：当设备宽度小于或等于指定值时应用样式。

例如：

```css
@media (min-width: 600px) {
  .container {
    grid-template-columns: 1fr 1fr; /* 屏幕宽度大于等于600px时，使用两列布局 */
  }
}

@media (max-width: 600px) {
  .container {
    grid-template-columns: 1fr; /* 屏幕宽度小于600px时，使用单列布局 */
  }
}
```

## 总结

- **CSS Grid 布局**：通过定义行和列，能够精确控制元素的布局，适用于复杂的布局需求。
- **`grid-column` 和 `grid-row`**：用于控制元素在网格中所占的列和行，支持通过 `span` 关键字来跨越多个列或行。
- **[响应式 Web 设计](https://www.runoob.com/css/css-rwd-viewport.html)**：使用媒体查询来根据设备的屏幕大小调整页面布局和样式，保证页面在不同设备上的友好显示。

# Day 7

### CSS 动画

CSS 动画可以让元素**逐步改变样式**，而不是瞬间变化，主要有 **两种方式**：

1. **过渡（Transition）**：适用于简单的动画（状态变化，如 hover）
2. **关键帧动画（Animation）**：适用于复杂动画（如循环播放、逐帧变化）

------

## 1️⃣ **过渡（Transition）**

过渡用于**让元素的某些属性在一段时间内平滑变化**，通常结合 `hover` 使用。

### **📌 语法**

```css
transition: 属性名 时长 过渡效果 延迟时间;
```

`transition` 只需要在**原始状态**中定义，而不需要重复声明，它会**自动应用到被更改的属性**。

### **📝 示例**

```css
.box {
  width: 100px;
  height: 100px;
  background-color: red;
  transition: background-color 1s ease-in-out, transform 0.5s ease;//动画过渡两个属性background-color和transform
}

.box:hover {
  background-color: blue;
  transform: scale(1.2);
}
```

📌 **效果**：

- 当鼠标悬停，`background-color` 1s 内变蓝
- `transform: scale(1.2)` 让元素放大 1.2 倍，动画时间 0.5s

### **✨ 过渡参数**

| 参数                         | 作用                                                     |
| ---------------------------- | -------------------------------------------------------- |
| `transition-property`        | 过渡的 CSS 属性（如 `width`、`opacity`）                 |
| `transition-duration`        | 过渡的持续时间（如 `0.5s`）                              |
| `transition-timing-function` | 过渡的缓动函数（控制加速、减速）(ease 、linear、ease-in) |
| `transition-delay`           | 过渡开始前的延迟时间                                     |

------

## 2️⃣ **关键帧动画（Animation）**

如果需要**更复杂的动画（比如无限循环的动画）**，就要用 `@keyframes` 定义动画。

请用百分比来规定变化发生的时间，或用关键词 "from" 和 "to"，等同于 0% 和 100%。

### **📌 语法**

```css
@keyframes 动画名称 {
  0%   { 样式1 }
  50%  { 样式2 }
  100% { 样式3 }
}

.element {
  animation: 动画名称 时长 过渡方式 延迟时间 循环次数 方向;
}
```

### **📝 示例**

```css
@keyframes move {
  0%   { transform: translateX(0px); }
  50%  { transform: translateX(100px); }
  100% { transform: translateX(0px); }
}

.box {
  width: 100px;
  height: 100px;
  background-color: red;
  animation: move 2s ease-in-out infinite;
}
```

📌 **效果**：

- `move` 动画 2 秒内**左右移动**
- `infinite` 让动画无限循环

------

### **✨ `animation` 详解**

是以下所有动画属性的总简写

| 属性                        | 作用                         |
| --------------------------- | ---------------------------- |
| `animation-name`            | 关键帧名称                   |
| `animation-duration`        | 动画时长（如 `2s`）          |
| `animation-timing-function` | 速度曲线（如 `ease-in-out`） |
| `animation-delay`           | 动画开始前的延迟             |
| `animation-iteration-count` | 播放次数（如 `infinite`）    |
| `animation-direction`       | 正常、反向、往返播放         |

#### **🎨 方向（`animation-direction`）**

| 值                  | 作用               |
| ------------------- | ------------------ |
| `normal`            | 正常播放（默认）   |
| `reverse`           | 反向播放           |
| `alternate`         | **先正向、再反向** |
| `alternate-reverse` | **先反向、再正向** |

